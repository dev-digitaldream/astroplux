#!/usr/bin/env node
// Sync PluXML JSON export to Astro content collections
// - Articles -> src/content/blog/pluxml/*.md
// - Pages    -> src/content/pages/pluxml/*.md (if provided)
// Node 18+: relies on global fetch.

import fs from "node:fs";
import path from "node:path";
import process from "node:process";
import slugify from "slugify";
import { fileURLToPath } from "node:url";
import { setTimeout as sleep } from "node:timers/promises";

// ---------- Config ----------
const EXPORT_URL = process.env.PLUXML_EXPORT_URL || "https://alaoui.be/pluxml/export.php";
const SETTINGS_URL = process.env.PLUXML_SETTINGS_URL || ""; // optional: plugin settings endpoint
const ROOT = process.cwd();
const BLOG_DIR = path.join(ROOT, "src", "content", "blog", "pluxml");
const PAGES_DIR = path.join(ROOT, "src", "content", "pages", "pluxml");
const SITE_CONFIG_TS = path.join(ROOT, "src", "site.config.ts");

// ---------- Utils ----------
const c = {
  green: (s) => `\x1b[32m${s}\x1b[0m`,
  yellow: (s) => `\x1b[33m${s}\x1b[0m`,
  red: (s) => `\x1b[31m${s}\x1b[0m`,
  cyan: (s) => `\x1b[36m${s}\x1b[0m`,
  gray: (s) => `\x1b[90m${s}\x1b[0m`,
};

// Image allowlist via env: IMAGE_ALLOWLIST="domain1.com,domain2.com" (empty = allow all)
function isAllowedImageSrc(src) {
  const list = (process.env.IMAGE_ALLOWLIST || "").split(/[\,\s]+/).filter(Boolean);
  if (list.length === 0) return true;
  try {
    const u = new URL(src, "http://dummy");
    const host = u.hostname.toLowerCase();
    return list.some((d) => host === d.toLowerCase() || host.endsWith(`.${d.toLowerCase()}`));
  } catch {
    return false;
  }
}

function ensureDir(dir) {
  fs.mkdirSync(dir, { recursive: true });
}

function cleanDir(dir) {
  if (!fs.existsSync(dir)) return;
  for (const f of fs.readdirSync(dir)) {
    if (f.endsWith(".md")) fs.unlinkSync(path.join(dir, f));
  }
}

// Serialize strings safely for YAML frontmatter using JSON stringification
function y(value, fallback = "") {
  const v = value == null || value === "" ? fallback : value;
  return JSON.stringify(v);
}

function toISODate(d, fallback = "2025-01-01") {
  if (!d) return fallback;
  const dt = new Date(d);
  if (isNaN(dt.getTime())) return fallback;
  return dt.toISOString().slice(0, 10);
}

function toSlug(input, fallback = "untitled") {
  const base = (input && String(input).trim()) || fallback;
  return slugify(base, { lower: true, strict: true, locale: "fr" });
}

function toTags(tags) {
  if (!tags) return [];
  if (Array.isArray(tags)) return tags.map((t) => String(t));
  return String(tags)
    .split(/[;,]/)
    .map((t) => t.trim())
    .filter(Boolean);
}

function writeMarkdownLike(filePath, frontmatter, bodyLines) {
  const lines = ["---", ...frontmatter, "---", "", ...bodyLines, ""];
  fs.writeFileSync(filePath, lines.join("\n"), { encoding: "utf8" });
}

function writeSiteConfig(config) {
  // Accept common keys from export and map to our config
  const name = config?.site_title || config?.title || config?.name || "Astro Nano";
  const description = config?.site_description || config?.description || "Astro Nano is a minimal and lightweight blog and portfolio.";
  const email = config?.email || config?.site_email || "markhorn.dev@gmail.com";
  const socials = Array.isArray(config?.socials) ? config.socials : [];
  const theme = config?.theme || {};

  const content = `// Generated by sync-pluxml.mjs\nexport const SITE_CONFIG = {\n  NAME: ${y(name)},\n  EMAIL: ${y(email)},\n  HOME_TITLE: ${y(name)},\n  HOME_DESCRIPTION: ${y(description)},\n  BLOG_TITLE: "Blog",\n  BLOG_DESCRIPTION: ${y(description)},\n  WORK_TITLE: "Work",\n  WORK_DESCRIPTION: "Where I have worked and what I have done.",\n  PROJECTS_TITLE: "Projects",\n  PROJECTS_DESCRIPTION: "A collection of my projects, with links to repositories and demos.",\n  SOCIALS: ${JSON.stringify(socials)},\n  THEME: ${JSON.stringify(theme)}\n} as const;\n`;

  fs.writeFileSync(SITE_CONFIG_TS, content, { encoding: "utf8" });
}

// ---------- Mapping ----------
function mapArticle(item) {
  const title = item.title || item.name || item.titre || "Sans titre";
  const slug = item.slug || item.url || toSlug(title);
  const description = item.description || item.chapo || item.excerpt || title;
  const date = item.date || item.published_at || item.pubdate || item.created_at;
  const category = item.category || item.categorie || "blog";
  const tags = toTags(item.tags || item.mots_cles);
  const excerpt = item.excerpt || item.chapo || "";
  const html = item.content || item.html || item.body || "";
  const metaTitle = item.meta_title || item.seo_title || title;
  const metaDescription = item.meta_description || description;
  const cover = item.cover || item.image || item.cover_image || "";

  const fm = [
    `title: ${y(title)}`,
    `description: ${y(description)}`,
    `date: ${y(toISODate(date))}`,
    `category: ${y(category)}`,
    `tags: ${JSON.stringify(tags)}`,
    `excerpt: ${y(excerpt)}`,
    `metaTitle: ${y(metaTitle)}`,
    `metaDescription: ${y(metaDescription)}`,
    `cover: ${y(cover)}`,
  ];
  return { slug, fm, html };
}

function mapPage(item) {
  const title = item.title || item.name || item.titre || "Sans titre";
  const slug = item.slug || item.url || toSlug(title);
  const description = item.description || item.excerpt || title;
  const html = item.content || item.html || item.body || "";
  const metaTitle = item.meta_title || item.seo_title || title;
  const metaDescription = item.meta_description || description;
  const cover = item.cover || item.image || item.cover_image || "";
  const fm = [
    `title: ${y(title)}`,
    `description: ${y(description)}`,
    `metaTitle: ${y(metaTitle)}`,
    `metaDescription: ${y(metaDescription)}`,
    `cover: ${y(cover)}`,
  ];
  return { slug, fm, html };
}

// ---------- Main ----------
async function main() {
  console.log(c.cyan(`Sync PluXML → Astro starting`));
  console.log(c.gray(`EXPORT_URL=${EXPORT_URL}`));

  ensureDir(BLOG_DIR);
  ensureDir(PAGES_DIR);

  try {
    const res = await fetch(EXPORT_URL, { headers: { Accept: "application/json" } });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const data = await res.json();

    const articles = data.articles || data.posts || data.items || [];
    const pages = data.pages || [];

    // Optionally fetch site settings from plugin endpoint and merge
    if (SETTINGS_URL) {
      try {
        const sres = await fetch(SETTINGS_URL, { headers: { Accept: "application/json" } });
        if (sres.ok) {
          const sjson = await sres.json();
          data.config = { ...(data.config || {}), ...(sjson || {}) };
        }
      } catch {}
    }

    // Clean only generated folders
    cleanDir(BLOG_DIR);
    cleanDir(PAGES_DIR);

    let postCount = 0;
    for (const it of articles) {
      const mapped = mapArticle(it);
      const { rendered, usedMdx } = await transformHtmlImagesToMdx(
        mapped.slug,
        mapped.html
      );
      const ext = usedMdx ? ".mdx" : ".md";
      const file = path.join(BLOG_DIR, `${mapped.slug}${ext}`);
      writeMarkdownLike(file, mapped.fm, rendered);
      postCount++;
    }

    let pageCount = 0;
    for (const p of pages) {
      const mapped = mapPage(p);
      const { rendered, usedMdx } = await transformHtmlImagesToMdx(
        mapped.slug,
        mapped.html
      );
      const ext = usedMdx ? ".mdx" : ".md";
      const file = path.join(PAGES_DIR, `${mapped.slug}${ext}`);
      writeMarkdownLike(file, mapped.fm, rendered);
      pageCount++;
    }

    console.log(c.green(`✓ Synced ${postCount} articles`));
    if (pages.length) console.log(c.green(`✓ Synced ${pageCount} pages`));
    // Site config if provided
    const siteCfg = data.config || data.site || null;
    if (siteCfg) {
      writeSiteConfig(siteCfg);
      console.log(c.green("✓ Updated site config"));
    }
    console.log(c.cyan(`Done.`));
  } catch (err) {
    // Do not fail the build if remote is unreachable
    console.log(c.yellow(`! Sync skipped: ${err?.message || err}`));
    console.log(c.gray(`Proceeding without updated content.`));
  }
}

async function watchLoop(ms) {
  console.log(c.cyan(`Watching for changes every ${ms}ms...`));
  // naive polling; re-run sync each tick
  // Intentionally no diffing to keep simple and robust
  // Errors are already handled in main()
  // eslint-disable-next-line no-constant-condition
  while (true) {
    await main();
    await sleep(ms);
  }
}

const args = process.argv.slice(2);
const isWatch = args.includes("--watch");
const intervalArg = args.find((a) => a.startsWith("--interval="));
const interval = intervalArg ? parseInt(intervalArg.split("=")[1], 10) : 15000;

if (isWatch) {
  watchLoop(interval).catch((e) => {
    console.error(c.red(`Watch errored: ${e?.message || e}`));
    process.exit(1);
  });
} else {
  main();
}

// ---------- Images → astro:assets (MDX) ----------
// Find <img ...> in HTML, download to src/assets, and emit MDX imports + <Image /> tags
async function transformHtmlImagesToMdx(slug, html) {
  if (!html || !/<img\s/i.test(html)) {
    return { rendered: [html || ""], usedMdx: false };
  }

  const ASSET_DIR = path.join(ROOT, "src", "assets", "pluxml", slug);
  ensureDir(ASSET_DIR);

  const imgRegex = /<img\s+([^>]*?)src=["']([^"']+)["']([^>]*)>/gi;
  const imports = ["import { Image } from 'astro:assets';"]; // MDX ESM import
  const replacements = [];
  const seen = new Map();
  let match;
  let idx = 1;

  while ((match = imgRegex.exec(html)) !== null) {
    const full = match[0];
    const pre = match[1] || "";
    const src = match[2];
    const post = match[3] || "";

    // Only handle http(s) or absolute path images; skip data URIs
    if (!/^https?:\/\//i.test(src) && !src.startsWith("/")) continue;
    if (!isAllowedImageSrc(src)) {
      console.log(c.gray(`skip image (not allowed): ${src}`));
      continue;
    }

    let varName = seen.get(src);
    if (!varName) {
      const fileName = safeFileName(src);
      const dest = path.join(ASSET_DIR, fileName);
      try {
        await download(src, dest);
        varName = `Img${idx++}`;
        imports.push(`import ${varName} from '@/assets/pluxml/${slug}/${fileName}';`);
        seen.set(src, varName);
      } catch (e) {
        console.log(c.yellow(`! image fetch failed: ${src} (${e?.message || e})`));
        continue;
      }
    }

    const altMatch = /alt=["']([^"']*)["']/i.exec(full);
    const alt = altMatch ? altMatch[1] : "";
    const titleMatch = /title=["']([^"']*)["']/i.exec(full);
    const title = titleMatch ? ` title=\"${escapeAttr(titleMatch[1])}\"` : "";
    const classMatch = /class=["']([^"']*)["']/i.exec(full);
    const className = classMatch ? ` className=\"${escapeAttr(classMatch[1])}\"` : "";

    const jsx = `<Image src={${varName}} alt=${JSON.stringify(alt)} loading="lazy" decoding="async"${title}${className} />`;
    replacements.push({ target: full, jsx });
  }

  if (replacements.length === 0) {
    return { rendered: [html], usedMdx: false };
  }

  let body = html;
  for (const r of replacements) {
    body = body.split(r.target).join(r.jsx);
  }

  const lines = [
    ...imports,
    "",
    body,
  ];
  return { rendered: lines, usedMdx: true };
}

function safeFileName(u) {
  try {
    const url = new URL(u, "http://dummy");
    const base = path.basename(url.pathname);
    return base || `img-${Date.now()}.jpg`;
  } catch {
    const base = path.basename(u.split("?")[0]);
    return base || `img-${Date.now()}.jpg`;
  }
}

async function download(url, dest) {
  const res = await fetch(url);
  if (!res.ok) throw new Error(`HTTP ${res.status}`);
  const arrayBuffer = await res.arrayBuffer();
  fs.writeFileSync(dest, Buffer.from(arrayBuffer));
}

function escapeAttr(s) {
  return String(s).replace(/"/g, '&quot;').replace(/\n/g, ' ');
}
